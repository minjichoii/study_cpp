# 📡 백준 2493번 - "탑"

## 🔹 문제 설명
- N개의 탑이 왼쪽부터 오른쪽으로 나열되어 있음.
- 각 탑은 **왼쪽 방향**으로 레이저 신호를 발사함.
- **신호를 가장 먼저 받는 탑의 번호**를 출력해야 함.
- 신호를 받을 수 있는 탑이 없다면 `0`을 출력해야 함.

## 🛠 **풀이 방법 (스택을 이용한 최적화)**
### 1️⃣ **탑의 신호 수신 원리**
- **첫 번째 탑**은 왼쪽에 아무것도 없으므로 무조건 `0` 출력.
- **두 번째 탑**은 첫 번째 탑보다 크다면 첫 번째 탑을 제거하고 `0`을 출력.
- **세 번째 이후의 탑**은 자신보다 작은 탑들을 pop하며 가장 가까운 왼쪽 탑을 찾음.
- 작은 탑들은 **어차피 신호를 받을 가능성이 없으므로 스택에서 제거하는 것이 최적화된 방식**.

### 2️⃣ **스택을 이용한 접근법**
- **각 탑의 정보를 `(인덱스, 높이)` 형태로 스택에 저장**
- **현재 탑보다 작은 탑들은 스택에서 제거(pop)** → 수신탑이 될 가능성이 없기 때문
- **현재 탑보다 크거나 같은 탑을 찾으면 출력 후 스택에 push**

## ⏳ **시간 복잡도 분석**
- **각 탑은 한 번 스택에 push, 한 번 pop 되므로 O(N)**.
- 최악의 경우 (`N = 500,000`)에도 빠르게 실행 가능!

## 📌 **코드 (C++)**
```cpp
#include <iostream>
#include <stack>

using namespace std;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int n;
    cin >> n;

    stack<pair<int,int>> tower;
    
    for (int i = 1; i <= n; i++) {
        int height;
        cin >> height;

        while (!tower.empty() && tower.top().second < height) {
            tower.pop();  // 현재 탑보다 낮은 탑은 pop
        }

        if (tower.empty()) {
            cout << 0 << " ";  // 수신탑이 없으면 0 출력
        } else {
            cout << tower.top().first << " ";  // 가장 가까운 왼쪽 탑의 번호 출력
        }

        tower.push({i, height});  // 현재 탑을 스택에 저장
    }
}
```

## ✅ **핵심 정리**
✔ **앞의 탑이 수신탑이 될 가능성이 없으면 pop** → 불필요한 탐색 제거
✔ **스택의 top이 현재 탑보다 크거나 같다면, 그것이 수신탑**
✔ **O(N)으로 최적화된 스택 활용법**
✔ **불필요한 pop 연산 없이 가장 가까운 수신탑을 빠르게 찾을 수 있음**

🚀 **최적화된 스택을 이용한 풀이로 빠르게 해결 가능!**

