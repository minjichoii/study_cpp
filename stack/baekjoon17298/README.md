# 📌 백준 17298번 - 오큰수 (Next Greater Element)

## **🚀 내 첫 번째 풀이의 부족한 점과 최적화**

### **1️⃣ 내 첫 번째 풀이 (왼쪽 → 오른쪽 진행)**
#### **✅ 접근 방식**
- 왼쪽에서 오른쪽으로 진행하면서 스택을 사용.
- 현재 숫자보다 작은 값들을 `pop()`해서 제거.
- 스택이 비어있으면 `-1`, 있으면 `top()`을 출력.
- 현재 값을 `push()`하여 이후 숫자들이 참조할 수 있도록 함.

#### **⚠️ 부족한 점**
1. **시간 복잡도가 최악 `O(N^2)` 가능성**  
   - 왼쪽에서 오른쪽으로 진행하면서, 각 숫자마다 스택을 여러 번 pop()할 수 있음.
   - 예를 들어 오름차순 정렬된 입력 (`1 2 3 4 5`)일 경우, **모든 숫자가 `pop()`을 반복적으로 수행**하여 최악의 경우 `O(N^2)`이 됨.

2. **중간 결과가 필요 없이 바로 출력하는 방식이라서 비효율적**  
   - `cout`을 반복적으로 실행하여 출력을 처리하기 때문에 속도가 느릴 수 있음.

3. **오른쪽에서 더 큰 수를 찾는 과정이 비효율적**  
   - 현재 숫자가 오큰수를 찾기 위해 **자기 앞쪽의 모든 숫자를 비교해야 할 수도 있음**.

#### **🔍 핵심 코드 부분**
```cpp
while (!a.empty() && a.top() <= num) {
    a.pop();
}
if (a.empty()) {
    cout << -1 << " ";
} else {
    cout << a.top() << " ";
}
a.push(num);
```

---

### **2️⃣ 최적화된 풀이 (오른쪽 → 왼쪽 진행)**
#### **✅ 개선된 점**
1. **시간 복잡도가 `O(N)`으로 최적화됨**  
   - 오른쪽에서 왼쪽으로 진행하면서 `스택`을 유지하면, **각 숫자는 한 번만 push/pop 됨**.
   - 즉, 모든 원소가 최대 한 번씩만 pop() 되므로 **`O(N)`에 해결 가능**.

2. **불필요한 `pop()` 연산 최소화**  
   - 현재 숫자가 더 큰 수를 찾기 위해 굳이 **왼쪽의 모든 숫자들을 탐색할 필요가 없음**.
   - 오른쪽에서 진행하면서 스택을 유지하면, **한 번의 pop() 연산만으로 "가장 가까운 큰 수"를 찾을 수 있음**.

3. **결과를 `vector<int>` 배열에 저장하고 한 번에 출력**  
   - `cout`을 반복 호출하지 않고, 배열에 저장 후 마지막에 출력하면 실행 속도가 빨라짐.

#### **🔍 핵심 코드 부분**
```cpp
for (int i = n - 1; i >= 0; i--) { // 오른쪽 -> 왼쪽 진행
    while (!s.empty() && s.top() <= a[i]) {
        s.pop();
    }
    ans[i] = s.empty() ? -1 : s.top();
    s.push(a[i]);
}
```

---

## **📊 두 풀이 비교**

| 비교 항목 | **내 첫 번째 풀이 (왼쪽 → 오른쪽)** | **최적화된 풀이 (오른쪽 → 왼쪽)** |
|----------|--------------------------------|--------------------------------|
| **탐색 방향** | 왼쪽 → 오른쪽 | 오른쪽 → 왼쪽 |
| **스택 활용 방식** | 현재 숫자가 작은 애들을 pop() | 현재 숫자가 작은 애들을 pop() |
| **결과 저장 방식** | 바로 `cout`으로 출력 | 배열 `ans[]`에 저장 후 출력 |
| **시간 복잡도** | `O(N^2)` (최악의 경우 pop() 많음) | `O(N)` (각 숫자는 최대 한 번 push/pop) |
| **메모리 사용** | `stack<int>` | `stack<int>` + `vector<int>` (배열) |

---

## **🎯 결론**
 **✅ 왼쪽에서 오른쪽으로 진행해도 문제 해결 가능하지만, 비효율적일 수 있음.**  
 **✅ 오른쪽에서 왼쪽으로 진행하면 각 원소가 최대 1번만 pop() → `O(N)`으로 최적화 가능.**  
 **✅ 스택을 활용한 "최적화된 풀이"가 더 빠르고 효율적.** 🚀  

📌 **탐색 방향을 바꾸는 것만으로도 큰 성능 차이가 발생할 수 있음!**

